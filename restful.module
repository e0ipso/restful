<?php

/**
 * @file
 * Turn Drupal to a RESTful server, following best practices.
 */

/**
 * Implements hook_ctools_plugin_directory().
 */
function restful_ctools_plugin_directory($module, $plugin) {
  if ($module == 'restful') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Add defaults values to the notifier plugins.
 *
 * - 'description': The description of the plugin.
 * - 'options': Array with the following keys:
 *   - 'save on fail': Save the message is delivery failed. Defaults to
 *     TRUE.
 *   - 'save on success': Save the message is delivery successded. Defaults to
 *     TRUE.
 *   - 'language override': Override user's language, and use the
 *     Message's language. Defaults to FALSE.
 *   - 'rendered fields': Array keyed with the view mode(s), and the text
 *     field(s) to save the rendered output.
 *     The rendered field is used when it is needed to save the message
 *     exactly as it was sent (for example for message logs), as it might
 *     change and show differently when viewed later - as a result of on
 *     the fly token replacement, or even editing the message type.
 */
function restful_plugin_process(&$plugin, $info) {
  $plugin += array(
    'description' => '',
    'options' => array(),
    'major_version' => 1,
    'minor_version' => 0,
    'entity_type' => FALSE,
    'bundle' => FALSE,
  );

  $plugin['options'] += array(
  );
}

/**
 * Implements hook_ctools_plugin_type().
 */
function restful_ctools_plugin_type() {
  $plugins['restful'] = array(
    'classes' => array('class'),
    'process' => 'restful_plugin_process',
  );
  return $plugins;
}


/**
 * Helper function to include CTools plugins and get all restful plugins.
 */
function restful_get_restful_plugins() {
  ctools_include('plugins');
  return ctools_get_plugins('restful', 'restful');
}

/**
 * Implements hook_menu().
 */
function restful_menu() {
  $items = array();
  $base_path = variable_get('restful_hook_menu_base_path', 'api/%');
  foreach (restful_get_restful_plugins() as $plugin) {
    $resource = $plugin['resource'];
    $items[$base_path . '/' . $resource] = array(
      'title' => $plugin['name'],
      'access callback' => 'restful_menu_access_callback',
      'access arguments' => array(1, 2),
      'page callback' => 'restful_menu_process_callback',
      'page arguments' => array(1, 2),
    );
  }
  return $items;
}


/**
 * Return the handler based on major and minor version, and resource name.
 *
 * @param $resource_name
 *   The name of the resource (e.g. "articles").
 * @param int $major_version
 *   (optional) The major version (not prefixed with "v"). Defaults to 1.
 * @param int $minor_version
 *   (optional) The minor version. Defaults to 0.
 *
 * @return RestfulInterface | NULL
 *   The handler object if found, or NULL.
 */
function restful_get_restful_handler($resource_name, $major_version = 1, $minor_version = 0) {
  $cache = &drupal_static(__FUNCTION__);
  $identifier = implode(':', array($major_version, $resource_name, $minor_version));
  if (isset($cache[$identifier])) {
    return $cache[$identifier];
  }

  $cache[$identifier] = NULL;


  // Array with all the handlers with the same major version and resource name.
  // We get all of them, so we can find the correct one if minor version is
  // present.
  $valid_plugins = array();
  foreach (restful_get_restful_plugins() as $name => $plugin) {
    if ($plugin['major_version'] != $major_version) {
      continue;
    }

    if ($plugin['resource'] != $resource_name) {
      continue;
    }

    if ($minor_version == $plugin['minor_version']) {
      // We found out handler, so we can break.
      $valid_plugins[$plugin['minor_version']] = $plugin;
      break;
    }

    if ($plugin['minor_version'] > $minor_version) {
      // Minor version is above the needed one.
      continue;
    }

    $valid_plugins[$plugin['minor_version']] = $plugin;
  }

  if (!$valid_plugins) {
    return;
  }

  // Sort the handlers, and get the last one, as it is the closest one to the
  // requested minor version.
  ksort($valid_plugins);
  $plugin = end($valid_plugins);

  $class = ctools_plugin_load_class('restful', 'restful', $plugin['name'], 'class');
  $cache[$identifier] = new $class($plugin);
  return $cache[$identifier];
}


/**
 * Access callback; Determine access for an API call.
 *
 * @param $major_version
 *   The major version, prefixed with v (e.g. v1, v2).
 * @param $resource_name
 *   The name of the resource (e.g. "articles").
 *
 * @return
 *   TRUE if user is allowed to access resource.
 */
function restful_menu_access_callback($major_version, $resource_name) {
  if ($major_version[0] != 'v') {
    // Major version not prefixed with "v".
    return;
  }

  if (!$major_version = intval(str_replace('v', '', $major_version))) {
    // Major version is not an integer.
    return;
  }

  $minor_version = !empty($_SERVER['HTTP_RESTFUL_MINOR_VERSION']) && is_int($_SERVER['HTTP_RESTFUL_MINOR_VERSION']) ? $_SERVER['HTTP_RESTFUL_MINOR_VERSION'] : 0;
  if (!$handler = restful_get_restful_handler($resource_name, $major_version, $minor_version)) {
    return;
  }

  if (!in_array($_SERVER['REQUEST_METHOD'], array('GET', 'POST', 'PUT', 'PATCH', 'DELETE'))) {
    return;
  }

  return $handler->access();
}

/**
 * Page callback; Return the response for an API call.
 *
 * @param $major_version
 *   The major version, prefixed with v (e.g. v1, v2).
 * @param $resource_name
 *   The name of the resource (e.g. "articles").
 *
 * @return
 *   JSON output with the result of the API call.
 */
function restful_menu_process_callback($major_version, $resource_name) {
  $major_version = intval(str_replace('v', '', $major_version));
  $minor_version = !empty($_SERVER['HTTP_RESTFUL_MINOR_VERSION']) && is_numeric($_SERVER['HTTP_RESTFUL_MINOR_VERSION']) ? $_SERVER['HTTP_RESTFUL_MINOR_VERSION'] : 0;
  $handler = restful_get_restful_handler($resource_name, $major_version, $minor_version);

  $path = func_get_args();
  unset($path[0], $path[1]);
  $path = implode('/', $path);

  $request = array();
  $method = strtolower($_SERVER['REQUEST_METHOD']);

  switch ($method) {
    case 'get':
      $request = $_GET;
      break;

    case 'post':
    case 'patch':
    case 'put':
      $request = $_POST;
  }

  // Determine if request was successful.
  $success = FALSE;

  if (method_exists($handler, $method)) {
    try {
      $result = $handler->{$method}($path, $request);
      $success = TRUE;
    }
    catch (RestfulException $e) {
      drupal_add_http_header('Status', $e->getCode());
      $result = array(
        'code' => $e->getCode(),
        'message' => $e->getMessage(),
        'description' => $e->getDescription(),
      );
    }
    catch (Exception $e) {
      $result = array(
        'code' => 500,
        'message' => $e->getMessage(),
      );
    }

    if ($success) {
      // Allow the handler to change the HTTP headers.
      foreach ($handler->getHttpHeaders() as $key => $value) {
        drupal_add_http_header($key, $value);
      }
    }
  }
  else {
    $result = array(
      'code' => 406,
      'message' => format_string('HTTP Method @method is invalid.', array('@method' => $method)),
    );
  }


  return drupal_json_output($result);
}
